p_m=matrix(1,ncol=dim(cr_mat)[1],nrow=dim(cr_mat)[2])
m<-data.frame(m,row.names = colnames(c1_data))
p_m<-data.frame(p_m,row.names = colnames(c1_data))
colnames(m)<-colnames(c1_data)
colnames(p_m)<-colnames(c1_data)
r2<-function(model,col=i,data=c1_data){
sse=sum((predict(model,data)-data[[col]])^2)
tss=sum((data[[col]]-mean(data[[col]]))^2)
error=1-(sse/tss)
return(error)
}
for (i in 1:539){
x_nam=rownames(cr_mat)[i]
ind1=abs(cr_mat[i,]) > 0.05 & abs(cr_mat[i,]) != 1
cool=which(ind1, arr.ind = T)
y_nam=rownames(as.data.frame(cool)) #Column names with correlation >0.05
if(identical(y_nam,character(0)) == TRUE){next}
print(x_nam) #Row name
#Formula
form=as.formula(paste(x_nam,paste(y_nam,collapse = "+"),sep="~"))
glm(form,data=c1_data )
#GLMBoosting and Model Tuning, Depends on randomness
model1<-glmboost(form,data=c1_data,family = Gaussian(),
center=TRUE,control = boost_control(mstop=200,nu=0.05,trace=TRUE))
#Induces randomness, can loop and take the nearest average integer
f<-cv(model1$`(weights)`,type="kfold",B=10)
cvm<-cvrisk(model1,folds=f)
opt_m<-mstop(cvm)
if(opt_m==0){opt_m=1}
#Choosing the optimal model
model1[opt_m]
error=r2(model1,col=i)
if (error<0.5){next}
wghts<-coef(model1,which="")
x<-t(as.data.frame(wghts[-1]))
row.names(x)<-x_nam
#Appending the coefficient matrix to adjacency matrix
for(cl in colnames(x)){
m[x_nam,cl]<-x[x_nam,cl]
}
#Bootstrap distribution
#------------Using boot-----------------
library(boot)
boot.stat<-function(data,indices,m_stop,form,x_nam){
data<-data[indices,]
mod<-glmboost(form,data=data,family = Gaussian(),
center=FALSE,control = boost_control(mstop=m_stop,nu=0.05,trace=TRUE))
wghts<-coef(mod,which="")
x<-t(as.data.frame(wghts[-1]))
row.names(x)<-x_nam
return(x)
}
model.boot<-boot(c1_data,boot.stat,100,m_stop=opt_m,form=form,x_nam=x_nam)
#-----------Permutation with renormalization-------------
#copy of the data
c1_data_p=c1_data
out_comb<-x
#permutation
counter=0
while (counter<100){
c1_data_p[[x_nam]]<-sample(c1_data_p[[x_nam]])
#renormalization
c1_data_p=(c1_data_p/rowSums(c1_data_p))*200
out<-boot.stat(c1_data_p,indices = 1:dim(c1_data)[1],m_stop=opt_m,form=form,x_nam=x_nam)
out_comb=rbind(out_comb,out)
counter = counter + 1
}
out_comb<-out_comb[-1,]
#Comparing two distributions
for (i in 1:dim(out_comb)[2]){
p=wilcox.test(model.boot$t[,i],out_comb[,i],alternative = "two.sided",paired = FALSE)$p.value
p_m[x_nam,colnames(out_comb)[i]]<-p
}
}
i
i=537
x_nam=rownames(cr_mat)[i]
ind1=abs(cr_mat[i,]) > 0.05 & abs(cr_mat[i,]) != 1
cool=which(ind1, arr.ind = T)
y_nam=rownames(as.data.frame(cool)) #Column names with correlation >0.05
if(identical(y_nam,character(0)) == TRUE){next}
print(x_nam) #Row name
i
y_nam
?p.adjust
x <- rnorm(50, mean = c(rep(0, 25), rep(3, 25)))
p <- 2*pnorm(sort(-abs(x)))
p
round(p, 3)
p
round(p.adjust(p), 3)
round(p.adjust(p), 3)
round(p.adjust(p, "BH"), 3)
out_comb
#Reading the dataset
data=read.csv("data_combined.csv")
rownames(data)<-data$PatientID
data$PatientID<-NULL
c1_data=subset(data,x==1)
c2_data=subset(data,x==2)
c1_data$x<-NULL
c2_data$x<-NULL
library(mboost)
# For c1_data
cr_mat=cor(c1_data,method = "spearman") #Compute Spearman Correlation
cr_mat[is.na(cr_mat)]<-0  # Assign 0 to NA values(NA due to zero STD)
#Adjacency matrix and p-value matrix creation
m=matrix(0,ncol=dim(cr_mat)[1],nrow=dim(cr_mat)[2])
p_m=matrix(2,ncol=dim(cr_mat)[1],nrow=dim(cr_mat)[2])
m<-data.frame(m,row.names = colnames(c1_data))
p_m<-data.frame(p_m,row.names = colnames(c1_data))
colnames(m)<-colnames(c1_data)
colnames(p_m)<-colnames(c1_data)
r2<-function(model,col=i,data=c1_data){
sse=sum((predict(model,data)-data[[col]])^2)
tss=sum((data[[col]]-mean(data[[col]]))^2)
error=1-(sse/tss)
return(error)
}
i=1
x_nam=rownames(cr_mat)[i]
ind1=abs(cr_mat[i,]) > 0.05 & abs(cr_mat[i,]) != 1
cool=which(ind1, arr.ind = T)
y_nam=rownames(as.data.frame(cool)) #Column names with correlation >0.05
if(identical(y_nam,character(0)) == TRUE){next}
print(x_nam) #Row name
#Formula
form=as.formula(paste(x_nam,paste(y_nam,collapse = "+"),sep="~"))
glm(form,data=c1_data )
#GLMBoosting and Model Tuning, Depends on randomness
model1<-glmboost(form,data=c1_data,family = Gaussian(),
center=TRUE,control = boost_control(mstop=200,nu=0.05,trace=TRUE))
#Induces randomness, can loop and take the nearest average integer
f<-cv(model1$`(weights)`,type="kfold",B=10)
cvm<-cvrisk(model1,folds=f)
opt_m<-mstop(cvm)
opt_m
error=r2(model1,col=i)
error
#Induces randomness, can loop and take the nearest average integer
f<-cv(model1$`(weights)`,type="kfold",B=10)
cvm<-cvrisk(model1,folds=f)
opt_m<-mstop(cvm)
opt_m
error=r2(model1,col=i)
error
i=10
x_nam=rownames(cr_mat)[i]
ind1=abs(cr_mat[i,]) > 0.05 & abs(cr_mat[i,]) != 1
cool=which(ind1, arr.ind = T)
y_nam=rownames(as.data.frame(cool)) #Column names with correlation >0.05
if(identical(y_nam,character(0)) == TRUE){next}
print(x_nam) #Row name
#Formula
form=as.formula(paste(x_nam,paste(y_nam,collapse = "+"),sep="~"))
glm(form,data=c1_data )
#GLMBoosting and Model Tuning, Depends on randomness
model1<-glmboost(form,data=c1_data,family = Gaussian(),
center=TRUE,control = boost_control(mstop=200,nu=0.05,trace=TRUE))
#Induces randomness, can loop and take the nearest average integer
f<-cv(model1$`(weights)`,type="kfold",B=10)
cvm<-cvrisk(model1,folds=f)
opt_m<-mstop(cvm)
opt_m
error=r2(model1,col=i)
error
#Induces randomness, can loop and take the nearest average integer
f<-cv(model1$`(weights)`,type="kfold",B=10)
cvm<-cvrisk(model1,folds=f)
opt_m<-mstop(cvm)
opt_m
#Induces randomness, can loop and take the nearest average integer
f<-cv(model1$`(weights)`,type="kfold",B=10)
cvm<-cvrisk(model1,folds=f)
opt_m<-mstop(cvm)
opt_m
i=100
x_nam=rownames(cr_mat)[i]
ind1=abs(cr_mat[i,]) > 0.05 & abs(cr_mat[i,]) != 1
cool=which(ind1, arr.ind = T)
y_nam=rownames(as.data.frame(cool)) #Column names with correlation >0.05
if(identical(y_nam,character(0)) == TRUE){next}
print(x_nam) #Row name
#Formula
form=as.formula(paste(x_nam,paste(y_nam,collapse = "+"),sep="~"))
glm(form,data=c1_data )
#GLMBoosting and Model Tuning, Depends on randomness
model1<-glmboost(form,data=c1_data,family = Gaussian(),
center=TRUE,control = boost_control(mstop=200,nu=0.05,trace=TRUE))
#Induces randomness, can loop and take the nearest average integer
f<-cv(model1$`(weights)`,type="kfold",B=10)
cvm<-cvrisk(model1,folds=f)
opt_m<-mstop(cvm)
error=r2(model1,col=i)
error
?cvrisk
model.weights(model1)
#Induces randomness, can loop and take the nearest average integer
f<-cv(model.weights(model1),type="kfold",B=10)
cvm<-cvrisk(model1,folds=f,papply = lapply)
opt_m<-mstop(cvm)
opt_m
#Induces randomness, can loop and take the nearest average integer
f<-cv(model.weights(model1),type="kfold",B=10)
cvm<-cvrisk(model1,folds=f,papply = lapply)
opt_m<-mstop(cvm)
opt_m
cvrisk(model1,papply = lapply)
cvrisk(model1,papply = lapply)
cvrisk(model1,papply = lapply)
cvrisk(model1,papply = lapply)
cvrisk(model1,papply = lapply)
cvrisk(model1,papply = lapply)
cvrisk(model1,papply = lapply)
cvrisk(model1,papply = lapply)
cvrisk(model1,papply = lapply)
cvrisk(model1,papply = lapply)
cvrisk(model1,papply = lapply)
#Induces randomness, can loop and take the nearest average integer
f<-cv(model.weights(model1),type="kfold",B=10)
cvm<-cvrisk(model1,folds=f,papply = lapply)
opt_m<-mstop(cvm)
opt_m
?cvrisk
cvrisk(model1,mc.cores=4)
cvrisk(model1,mc.cores=4)
cvrisk(model1,mc.cores=4)
#Induces randomness, can loop and take the nearest average integer
f<-cv(model.weights(model1),type="kfold",B=10)
cvm<-cvrisk(model1,folds=f,mc,cores=4)
#Induces randomness, can loop and take the nearest average integer
f<-cv(model.weights(model1),type="kfold",B=10)
#Induces randomness, can loop and take the nearest average integer
f<-cv(model.weights(model1),type="kfold",B=10)
cvm<-cvrisk(model1,folds=f,mc.cores=4)
opt_m<-mstop(cvm)
opt_m
m=c()
er=c()
for (i in 1:539){
x_nam=rownames(cr_mat)[i]
ind1=abs(cr_mat[i,]) > 0.05 & abs(cr_mat[i,]) != 1
cool=which(ind1, arr.ind = T)
y_nam=rownames(as.data.frame(cool)) #Column names with correlation >0.05
if(identical(y_nam,character(0)) == TRUE){next}
print(x_nam) #Row name
#Formula
form=as.formula(paste(x_nam,paste(y_nam,collapse = "+"),sep="~"))
model1<-glmboost(form,data=c1_data,family = Gaussian(),
center=TRUE,control = boost_control(mstop=200,nu=0.05,trace=TRUE))
f<-cv(model.weights(model1),type="kfold",B=10)
cvm<-cvrisk(model1,folds=f,mc.cores=4)
m=c(m,opt_m)
err=c(er,r2(model1,col=i))
}
plot(m,er)
m
er
er
m=c()
er=c()
for (i in 1:539){
x_nam=rownames(cr_mat)[i]
ind1=abs(cr_mat[i,]) > 0.05 & abs(cr_mat[i,]) != 1
cool=which(ind1, arr.ind = T)
y_nam=rownames(as.data.frame(cool)) #Column names with correlation >0.05
if(identical(y_nam,character(0)) == TRUE){next}
print(x_nam) #Row name
#Formula
form=as.formula(paste(x_nam,paste(y_nam,collapse = "+"),sep="~"))
model1<-glmboost(form,data=c1_data,family = Gaussian(),
center=TRUE,control = boost_control(mstop=200,nu=0.05,trace=TRUE))
f<-cv(model.weights(model1),type="kfold",B=10)
cvm<-cvrisk(model1,folds=f,mc.cores=4)
opt_m<-mstop(cvm)
m=c(m,opt_m)
er=c(er,r2(model1,col=i))
}
plot(m,er)
plot(er,m)
plot(er)
plot(m)
plot(er,m)
m=c()
m2=c()
m3=c()
er=c()
for (i in 1:539){
x_nam=rownames(cr_mat)[i]
ind1=abs(cr_mat[i,]) > 0.05 & abs(cr_mat[i,]) != 1
cool=which(ind1, arr.ind = T)
y_nam=rownames(as.data.frame(cool)) #Column names with correlation >0.05
if(identical(y_nam,character(0)) == TRUE){next}
print(x_nam) #Row name
#Formula
form=as.formula(paste(x_nam,paste(y_nam,collapse = "+"),sep="~"))
model1<-glmboost(form,data=c1_data,family = Gaussian(),
center=TRUE,control = boost_control(mstop=200,nu=0.05,trace=TRUE))
cvm<-cvrisk(model1,mc.cores=4)
opt_m<-mstop(cvm)
m=c(m,opt_m)
cvm<-cvrisk(model1,mc.cores=4)
opt_m<-mstop(cvm)
m2=c(m2,opt_m)
cvm<-cvrisk(model1,mc.cores=4)
opt_m<-mstop(cvm)
m3=c(m3,opt_m)
er=c(er,r2(model1,col=i))
}
plot(er,m)
plot(er,m,c="red")
plot(er,m,col="red")
plot(er,m,col="red")
plot(er,m2,col="red")
plot(er,m,col="red")
plot(er,m2,col="blue")
plot(er,m,col="red")
points(er,m2,col="blue")
points(er,m3,col="green")
#Reading the dataset
data=read.csv("data_combined.csv")
rownames(data)<-data$PatientID
data$PatientID<-NULL
c1_data=subset(data,x==1)
c2_data=subset(data,x==2)
c1_data$x<-NULL
c2_data$x<-NULL
library(mboost)
# For c1_data
cr_mat=cor(c1_data,method = "spearman") #Compute Spearman Correlation
cr_mat[is.na(cr_mat)]<-0  # Assign 0 to NA values(NA due to zero STD)
#Adjacency matrix and p-value matrix creation
m=matrix(0,ncol=dim(cr_mat)[1],nrow=dim(cr_mat)[2])
p_m=matrix(2,ncol=dim(cr_mat)[1],nrow=dim(cr_mat)[2])
m<-data.frame(m,row.names = colnames(c1_data))
p_m<-data.frame(p_m,row.names = colnames(c1_data))
colnames(m)<-colnames(c1_data)
colnames(p_m)<-colnames(c1_data)
r2<-function(model,col=i,data=c1_data){
sse=sum((predict(model,data)-data[[col]])^2)
tss=sum((data[[col]]-mean(data[[col]]))^2)
error=1-(sse/tss)
return(error)
}
i
i=2
x_nam=rownames(cr_mat)[i]
ind1=abs(cr_mat[i,]) > 0.05 & abs(cr_mat[i,]) != 1
cool=which(ind1, arr.ind = T)
y_nam=rownames(as.data.frame(cool)) #Column names with correlation >0.05
print(x_nam) #Row name
#Formula
form=as.formula(paste(x_nam,paste(y_nam,collapse = "+"),sep="~"))
#GLMBoosting and Model Tuning, Depends on randomness
model1<-glmboost(form,data=c1_data,family = Gaussian(),
center=TRUE,control = boost_control(mstop=200,nu=0.05,trace=TRUE))
#Induces randomness, can loop and take the nearest average integer
f<-cv(model.weights(model1),type="kfold",B=10)
cvm<-cvrisk(model1,folds=f,mc.cores=4)
AIC(model1)
AIC(model1[2])
AIC(model1[2])
AIC(model1[3])
plot(model1)
for (i in 1:69){}
aic=c()
for (i in 1:69){aic=c(aic,AIC(model1[i]))}
plot(aic)
?cvrisk
aic=c()
for (i in 1:69){aic=c(aic,r2(model1[i],col=i))}
plot(aic)
aic
max(aic)
which(max(aic))
max(aic)
cvrisk(model1)
cvrisk(model1)
cvrisk(model1)
cvrisk(model1)
cvrisk(model1)
cvrisk(model1)
cvrisk(model1)
cvrisk(model1)
cvrisk(model1)
max(aic)
max(aic)
cvrisk(model1)
cvrisk(model1,type"bootstrap")
cvrisk(model1,type="bootstrap")
cvrisk(model1,type="bootstrap")
x_nam=rownames(cr_mat)[i]
ind1=abs(cr_mat[i,]) > 0.05 & abs(cr_mat[i,]) != 1
cool=which(ind1, arr.ind = T)
y_nam=rownames(as.data.frame(cool)) #Column names with correlation >0.05
if(identical(y_nam,character(0)) == TRUE){next}
print(x_nam) #Row name
#Formula
form=as.formula(paste(x_nam,paste(y_nam,collapse = "+"),sep="~"))
#GLMBoosting and Model Tuning, Depends on randomness
model1<-glmboost(form,data=c1_data,family = Gaussian(),
center=TRUE,control = boost_control(mstop=200,nu=0.05,trace=TRUE))
cvrisk(model1,type="bootstrap")
cvrisk(model1)
cvrisk(model1)
cvrisk(model1)
cvrisk(model1)
cvrisk(model1)
model1
model1$risk()
model1$risk()
model1$risk()[-1]
model1$risk()
model1$risk()
tail(model1$risk())
tail(model1$risk(),n=1)
#Reading the dataset
data=read.csv("data_combined.csv")
rownames(data)<-data$PatientID
data$PatientID<-NULL
c1_data=subset(data,x==1)
c2_data=subset(data,x==2)
c1_data$x<-NULL
c2_data$x<-NULL
library(mboost)
# For c1_data
cr_mat=cor(c1_data,method = "spearman") #Compute Spearman Correlation
cr_mat[is.na(cr_mat)]<-0  # Assign 0 to NA values(NA due to zero STD)
#Adjacency matrix and p-value matrix creation
m=matrix(0,ncol=dim(cr_mat)[1],nrow=dim(cr_mat)[2])
p_m=matrix(2,ncol=dim(cr_mat)[1],nrow=dim(cr_mat)[2])
m<-data.frame(m,row.names = colnames(c1_data))
p_m<-data.frame(p_m,row.names = colnames(c1_data))
colnames(m)<-colnames(c1_data)
colnames(p_m)<-colnames(c1_data)
r2<-function(model,col=i,data=c1_data){
sse=sum((predict(model,data)-data[[col]])^2)
tss=sum((data[[col]]-mean(data[[col]]))^2)
error=1-(sse/tss)
return(error)
}
m=c()
m2=c()
m3=c()
m4=c()
m5=c()
er=c()
for (i in 1:539){
x_nam=rownames(cr_mat)[i]
ind1=abs(cr_mat[i,]) > 0.05 & abs(cr_mat[i,]) != 1
cool=which(ind1, arr.ind = T)
y_nam=rownames(as.data.frame(cool)) #Column names with correlation >0.05
if(identical(y_nam,character(0)) == TRUE){next}
print(x_nam) #Row name
#Formula
form=as.formula(paste(x_nam,paste(y_nam,collapse = "+"),sep="~"))
model1<-glmboost(form,data=c1_data,family = Gaussian(),
center=TRUE,control = boost_control(mstop=100,nu=0.05,trace=TRUE))
er=c(er,tail(model1$risk(),n=1))
cvm<-cvrisk(model1,mc.cores=4)
opt_m<-mstop(cvm)
m=c(m,opt_m)
cvm<-cvrisk(model1,mc.cores=4)
opt_m<-mstop(cvm)
m2=c(m2,opt_m)
cvm<-cvrisk(model1,mc.cores=4)
opt_m<-mstop(cvm)
m3=c(m3,opt_m)
cvm<-cvrisk(model1,mc.cores=4)
opt_m<-mstop(cvm)
m4=c(m4,opt_m)
cvm<-cvrisk(model1,mc.cores=4)
opt_m<-mstop(cvm)
m5=c(m5,opt_m)
}
plot(m,er)
plot(m,er,col="red")
points(m2,er,col="red")
plot(m,er,col="red")
plot(m2,er,col="blue")
plot(m3,er,col="green")
plot(m,er,col="red")
points(m2,er,col="blue")
points(m3,er,col="green")
points(m4,er,col="black")
points(m5,er,col="orange")
plot(er,m,col="red")
points(er,m2,col="blue")
points(er,m3,col="green")
points(er,m4,col="black")
points(er,m5,col="orange")
plot(er)
rbind(m,m2)
rbind(m,m2,m3,m4,m5)
x<-rbind(m,m2,m3,m4,m5)
y<-c()
for (i in 1:186){y<-c(y,var(x[,i]))}
y
plot(er,y)
er
plot(y)
plot(y,col="red")
plot(er,col="blue")
plot(y,col="red")
points(er,col="blue")
legend(legend = c("var","error"))
legend(150,1000,legend = c("var","error"))
legend(150,1500,legend = c("var","error"))
plot(y,col="red",pch=19)
points(er,col="blue",pch=18)
plot(er,y)
plot(y,er)
